__includes ["go_procedures//fence_behavior.nls" "go_procedures//food_behavior.nls" "go_procedures//nest_behavior.nls"]

extensions [table]

to go   
  ifelse current-time < night-duration [
   ask turtles [
      set state (list mass distance-from-nest)
      set action choose-action
      perform-action
      let reward calculate-reward
      set next-state (list mass distance-from-nest)
      update-q-table reward
    ]
    set current-time current-time + 1
    tick
  ] [
    stop
  ]
end 

to next-night
  while [current-time < night-duration] [
    go
  ]
  set current-time 0
  ask turtles [
    face-patch nest
    set distance-traveled 0
  ]
  reset-ticks
end

to face-patch [patch-to-face]
  face patch-to-face
  let angle heading
  let closest-angle first possible-angles
  let min-difference abs (closest-angle - angle)
  foreach possible-angles [ x ->
    let difference abs (x - angle)
    if difference < min-difference [
      set min-difference difference
      set closest-angle x
    ]
  ]
  set heading closest-angle
end

;;;;;;;;;;;;;;;;;;;;;;;;
;; Q-TABLE PROCEDURES ;;
;;;;;;;;;;;;;;;;;;;;;;;;

to-report distance-from-nest
  report distance nest
end

to-report choose-action
  ;; Wybór akcji na podstawie Q-table
    
  let best-action one-of possible-actions
  let max-q -99999
  
  ;; Priorytet dla powrotu do gniazda jeśli czas się kończy <-- dodać względem odległości od gniazda i pozostałego czasu
  ;;if remaining-time <= 10 [
    ;;set best-action "return-nest"
  ;;] else 
  ;;[
    foreach possible-actions [ ? ->
      let q table:get q-table (list state ?)
      if q = false [ set q 0 ]
      if q > max-q [
        set max-q q
        set best-action ?
      ]
    ]
    ;; Eksploracja nowych akcji
    if random-float 1 < 0.1 [ set best-action one-of possible-actions ]
  ;;]
  report best-action
end

to perform-action
  if action = "go-ahead" [ go-ahead ]
  if action = "forage" [ forage ]
  if action = "return-nest" [ move-towards-nest ]
  if action = "build-new-nest" [ build-new-nest ]
end

to go-ahead
  ;; Dodać logikę unikania ogrodzenia i ruchu
  ifelse can-move? 1 [
    forward 1
  ] [
    ;; Logika unikania przeszkód
    set heading (heading + 45)
  ]
end

to-report calculate-reward
  let reward 0
  
  ;; Nagroda za zebranie żywności
  if [pcolor] of patch-here = green [
    set reward reward + 10 ;; załóżmy, że zielone patche mają żywność
    set pcolor black ;; Po zebraniu żywność znika
  ]
  
  ;; Nagroda za powrót do gniazda przed końcem nocy
  ;;if remaining-time <= 10 and distance-from-nest <= 1 [
    ;;set reward reward + 50
  ;;]
  
  ;; Kara za zbyt duże oddalenie się od gniazda
  if distance-from-nest > 10 [
    set reward reward - 5
  ]
  
  report reward
end

to update-q-table [reward]
  let current-q table:get q-table (list state action)
  if current-q = false [ set current-q 0 ]
  
  ;;let max-next-q max [table:get q-table (list next-state ?1) 0] of possible-actions
  let max-next-q -99999
  foreach possible-actions [ ? ->
    let next-q table:get q-table (list next-state ?)
    if next-q = false [ set next-q 0 ]
    if next-q > max-next-q [
      set max-next-q next-q
    ]
  ]
    
  let new-q current-q + alpha * (reward + gamma * max-next-q - current-q)
  table:put q-table (list state action) new-q
end
