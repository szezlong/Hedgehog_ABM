__includes ["go_procedures//fence_behavior.nls" "go_procedures//food_behavior.nls" "go_procedures//nest_behavior.nls"]

extensions [table]

to go
  if not isEndState [
    ask hedgehogs [
      update-state-variables
       
      if not stay-in-nest [
;        while [not can-move? 1]
;          random-turn-hedgehog ;; krawędź świata
;        ]
        
        let old-position patch-here
        ;;ifelse nest != 0 [ set distance-to-nest distance nest ] [ set distance-to-nest -1 ]
       
        ;;rozmnazanie ale rozmnazanie tez moze sprawic ze przejdzie przez ulice
        if current-month >= 3 and current-month <= 8 [
          if sex = 0 and remaining-days = 0 [
            reproduce
          ]
        ]
        check-cross-street
        
        (qlearningextension:learning)
        
        if abs (heading - last-heading) = 180 [
          set flags lput "rotated-180" flags ;;sprawdz czy tego w ogole nie wywalic
        ]
        check-stuck
        set last-heading heading
        
        ask patch-here [
          set visit-count visit-count + 1
        ]
        set distance-traveled distance-traveled + distance old-position
      ]
      
      if current-time > (night-duration * 0.8) [
        if any? patches in-radius 4 with [ self = [nest] of myself ] [
          set distance-traveled distance-traveled + distance nest
          move-to nest ;;zakładam że zdążyłby wrócić <-- chyba że dzieli go jezdnia, to powinien podjąć ryzyko przejścia przez ulicę
        ]
        set stay-in-nest true
      ]
      if current-time + 1 >= night-duration and patch-here != nest[
        if patch-here = street [
          show "didn't reach the nest on time - died"
          kill-hedgehog
          ;;die ;;nie zdążył wrócić
        ]
        build-new-nest
      ]
      ;show flags
      
      update-visited-patches
    ]
    set current-time current-time + 1
    tick
    ]
end

to check-cross-street ;;można by też dodać hotspoty gdzie najczęściej jeże przechodzą przez ulicę
  ask hedgehogs [
    if patch-ahead 1 != nobody and [pcolor] of patch-ahead 1 = street [
      
      ;; Warunki przejścia przez drogę:
      ;; 1. Jeż ma niską masę ciała i potrzebuje jedzenia.
      ;; 2. Jeż zdąży wrócić do gniazda.
      ;; 3. Prawdopodobieństwo ruchu samochodowego (ryzyko).
      
      if (mass < low-mass-threshold and current-time < (night-duration * 0.5)) [
        if random-float 1 > 0.1 [
          ;;powinien zwrocic flage ze chce przejsc i wtedy wywoluje sie cross-street zamiast qlearning
          cross-street
        ]
      ]
    ]
  ]
end

to cross-street
  print "I'm crossing the street!"
  if random-float 1 < 0.5 [
    show "died while crossing the street"
    kill-hedgehog
  ] 
  let direction decide-direction ;;albo przed siebie
  move-along-fencing direction
  fd speed * 0.6 ;;po drodze poruszają się wolniej
end

to update-visited-patches 
  let current-patch patch-here
  set visited-patches lput current-patch visited-patches
  if length visited-patches > hedgehog-memory [
      set visited-patches but-first visited-patches
  ] 
end

to check-stuck
  let current-patch patch-here ;;czy qlearning cos da zeby tam nie szly?
  
  if member? "die" flags [
    ;15% szans że utknął i zginie
    ifelse random-float 1 < 0.85 [
      let available-patches-in-radius patches in-radius 3 with [member? self available-patches]
       ifelse any? available-patches-in-radius [
        let chosen-patch one-of available-patches-in-radius
        set distance-traveled distance-traveled + distance chosen-patch
        move-to chosen-patch
      ] [
        show "One got stuck and died :("
        kill-hedgehog
        ;;die
      ]
    ] [
      show "One got stuck and died :("
      kill-hedgehog
      ;;die
    ]
;  ] [ TO JEDNAK NIE ZAWIESZA
;    ifelse (not empty? visited-patches) and (current-patch = last visited-patches) [
;      ifelse (heading != last-heading) [
;        set stuck-count stuck-count + 1
;      ] [
;        set stuck-count 0
;      ]
;      if stuck-count > 10 [
;        show "got stuck with heading"
;       ;;kill-hedgehog
;        ;;die
;      ]
;    ] [
;      set stuck-count 0
;    ]
  ]
end

;;;;;;;;;;;;
; to opisz ;
;;;;;;;;;;;;
to face-patch [patch-to-face]
  face patch-to-face
  let angle heading
  let closest-angle first possible-angles
  let min-difference abs (closest-angle - angle)
  foreach possible-angles [ x ->
    let difference abs (x - angle)
    if difference < min-difference [
      set min-difference difference
      set closest-angle x
    ]
  ]
  set heading closest-angle
end


;;;;;;;;;;;;;;;;;
;; ROZMNAŻANIE ;;
;;;;;;;;;;;;;;;;;

to reproduce
  let intensity reproduction-intensity
  if random-float 1 < intensity [
    let search-radius ifelse-value (intensity > 0.7) [10] [5]  ;; Wyższa intensywność -> większy promień poszukiwań
    let nearby-females turtles with [sex = 1 and remaining-days = 0] in-radius search-radius
    
    if any? nearby-females [
      let chosen-female min-one-of nearby-females [distance myself]
      face-patch chosen-female
      let direction decide-direction
      move-along-fencing direction
      fd speed
      
      ;; 5. Sprawdź, czy kopulacja jest udana
      if random-float 1 < intensity [ ;; czy sa na tym samym patchu
        ;; Sukces kopulacji
        set remaining-days 3
        print (word "Samiec " who " skopił z samicą " [who] of chosen-female)
        ;; Logika tworzenia miotu tutaj
      ]
    ]
  ]
end

to-report reproduction-intensity
  ;; Faza 1: 21 marca - 30 marca (wzrost z 0 do 0.25)
  if current-month = 3 and current-day >= 21 [
    report (current-day - 20) / 10
  ]
  
  ;; Faza 1: 1 kwietnia - 30 kwietnia (wzrost z 0.25 do 1)
  if current-month = 4 [
    report 0.25 + (current-day / 30) * 0.75
  ]
  
  ;; Faza 2: 1 maja - 15 czerwca (maksimum, intensywność 1)
  if (current-month = 5) or (current-month = 6 and current-day <= 15) [
    report 1
  ]
  
  ;; Faza 3: 16 czerwca - 30 czerwca (spadek z 1 do 0.75)
  if current-month = 6 and current-day > 15 [
    report 1 - ((current-day - 15) / 15) * 0.25
  ]
  
  ;; Faza 3: 1 lipca - 30 lipca (spadek z 0.75 do 0.25)
  if current-month = 7 [
    report 0.75 - (current-day / 30) * 0.5
  ]
  
  ;; Faza 4: 1 sierpnia - 15 sierpnia (spadek z 0.25 do 0)
  if current-month = 8 and current-day <= 15 [
    report 0.25 - (current-day / 15) * 0.25
  ]
  
  ;; Poza okresem rozrodu
  report 0
end