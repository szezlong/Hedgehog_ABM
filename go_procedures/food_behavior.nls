to forage
  while [not can-move? 1] [
    random-turn-hedgehog ;; krawędź świata
  ]
  
  ;;if distance-traveled < max-distance [ ;; na razie tak, w przyszłości będzie do gniazda wracać
    move-towards-food-patch
    if random-float 1 < 0.1 [
      random-turn-hedgehog
    ]
  
    let direction decide-direction
    move-along-fencing direction
    fd speed

  set flags lput "forage" flags
  
  ask patch-here [
    set visit-count visit-count + 1
  ]
  
    ;;set distance-traveled distance-traveled + 1
  ;;]
  ;;]
end

to eat-food
  ifelse [food] of patch-here > 0 [
    ifelse mass < 8 [
      set mass mass + 1
      set flags lput "eat-food-big-success" flags
    ] [
      set mass mass + 0.5
      set flags lput "eat-food-success" flags
    ]
    ask patch-here [ set food food - 1 ]

  ] [
    ifelse mass > 15 [
      set flags lput "eat-food-big-fail" flags
    ] [ 
      set flags lput "eat-food-fail" flags
    ]
  ]
  
  ask patch-here [
    set visit-count visit-count + 1
  ]
end

to move-towards-food-patch
  let accessible-patches neighbors with [pcolor != fence]
  let sorted-patches reverse sort-on [food] accessible-patches
  let best-patch get-most-food sorted-patches
  
  if (best-patch != nobody) and ([food] of best-patch > [food] of patch-here) [
    face-patch best-patch
  ]
end

to-report get-most-food [sorted-patches]
  let length_of_list length visited-patches
  let last_visited item (length_of_list - 1) visited-patches
  let second_last_visited nobody
  
  if length_of_list > 2 [ set second_last_visited item (length_of_list - 2) visited-patches ]

  foreach sorted-patches [ x ->
    if second_last_visited = nobody or (x != last_visited and x != second_last_visited) [
      report x
    ]
  ]
end